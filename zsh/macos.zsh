### ZNAP
# Download Znap, if it's not there yet.
[[ -f ~/.zsh-plugins/zsh-snap/znap.zsh ]] ||
  git clone --depth 1 -- \
    https://github.com/marlonrichert/zsh-snap.git ~/.zsh-plugins/zsh-snap

# Start Znap
source ~/.zsh-plugins/zsh-snap/znap.zsh
###

znap source ohmyzsh/ohmyzsh

if [[ $TERM_PROGRAM == "WarpTerminal" ]]; then
  SPACESHIP_PROMPT_ASYNC=FALSE
fi

znap prompt spaceship-prompt/spaceship-prompt

# Custom RPROMPT segment for spaceship-prompt
spaceship_custom_project_root() {
  local root_folder=$(get_project_root)
  [[ -n $root_folder ]] && echo "$root_folder"
}

# Add custom segment to RPROMPT
# SPACESHIP_RPROMPT_ORDER=(
#   custom_project_root
# )

znap source zsh-users/zsh-completions
znap source zsh-users/zsh-autosuggestions

ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
znap source zsh-users/zsh-syntax-highlighting

znap source supercrabtree/k

omz_plugins=(
  "git"
  "npm"
  "macos"
  "fzf"
  "aliases"
)

for plugin in ${omz_plugins[@]}; do
  znap source ohmyzsh/ohmyzsh plugins/$plugin
done

export FZF_BASE=~[ohmyzsh/ohmyzsh]/plugins/fzf

znap eval brew-shellenv 'brew shellenv'

# https://github.com/roots/trellis-cli#virtualenv
# znap eval trellis 'trellis shell-init zsh'

export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && PYENV_BIN_PRESENT=1 || PYENV_BIN_PRESENT=0
if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init --path)"
  eval "$(pyenv init - --no-rehash)"
  eval "$(pyenv virtualenv-init -)"
fi
znap eval pyenv 'pyenv init --path; pyenv init - --no-rehash; pyenv virtualenv-init -'

# pip, Homebrew python, and other PATH entries are consolidated later

znap eval pip-completion 'pip completion --zsh'

# NVM
export NVM_COMPLETION=true
# export NVM_LAZY_LOAD=true
znap source lukechilds/zsh-nvm

if [[ $TERM_PROGRAM != "WarpTerminal" ]]; then
  export ITERM_ENABLE_SHELL_INTEGRATION_WITH_TMUX=YES
  znap eval iterm2 'curl -fsSL https://iterm2.com/shell_integration/zsh'
fi

export GPG_TTY=$(tty)

export NVM_DIR="$HOME/.nvm"
nvm_lazy_load() {
  unset -f nvm node npm npx
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"                   # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion
}

nvm() {
  nvm_lazy_load
  command nvm "$@"
}

node() {
  nvm_lazy_load
  command node "$@"
}

npm() {
  nvm_lazy_load
  command npm "$@"
}

npx() {
  nvm_lazy_load
  command npx "$@"
}

compdef _nvm nvm

# eval "$(op completion zsh)"
# compdef _op op

# system path ordering is handled in the consolidated PATH block below

# Home Assistant CLI
# eval "$(_HASS_CLI_COMPLETE=source_zsh hass-cli)"

alias sed=gsed # use gnu-sed instead of the mac osx sed

# export EDITOR="code --wait"
# alias codi="code-insiders"
# set -o vim
export EDITOR="vim"
# GitHub
alias gho="gh repo view -w" #TODO: make sure gh is installed
# TODO: add github command to copy repo URL directly in the clipboard

# =================== Spotify ===============================
# Spotify is supported using the OMZSH MacOS plugin. (using the official Spotify API)
# Raycast is also using the official API.

# do not register commands preceded by a space
export HISTCONTROL=ignorespace

# This script was automatically generated by the broot program
# More information can be found in https://github.com/Canop/broot
# This function starts broot and executes the command
# it produces, if any.
# It's needed because some shell commands, like `cd`,
# have no useful effect if executed in a subshell.
function br {
  local cmd cmd_file code
  cmd_file=$(mktemp)
  if broot --outcmd "$cmd_file" "$@"; then
    cmd=$(<"$cmd_file")
    command rm -f "$cmd_file"
    eval "$cmd"
  else
    code=$?
    command rm -f "$cmd_file"
    return "$code"
  fi
}

# fnm
FNM_PATH="/Users/sirius/Library/Application Support/fnm"
if [ -d "$FNM_PATH" ]; then
  export FNM_PATH
  eval "`fnm env`"
fi

eval "$(fnm env --use-on-cd --version-file-strategy=recursive --shell zsh)"

# Consolidate PATH modifications in one place to keep ordering predictable
# and avoid multiple scattered `export PATH=...` lines that can reorder
# or duplicate entries.
#
# Ordering rationale (earlier entries win):
# 1) `$PYENV_ROOT/bin` — if pyenv is active its shims should shadow system
#    Python when present (important for projects using pyenv-managed Python).
# 2) `$HOME/.local/bin` — user-installed tools (pipx, user pip installs) should
#    take precedence over system packages.
# 3) Homebrew Python shims (`/opt/homebrew/...`) — keep Homebrew-managed
#    Python tools next so they override system Python but not user-local installs.
# 4) `$FNM_PATH` — fnm/node shims should come before system node to honor
#    per-project Node versions.
# 5) `/usr/local/bin` then system bins — typical system-wide locations last.
#
# Implementation notes:
# - The loop prepends entries only if they are not already present, so the
#   operation is idempotent and safe to run multiple times.
# - Empty variables are skipped to avoid adding blank path entries.
{
  paths_to_prepend=(
    "$HOME/bin"
    "$PYENV_ROOT/bin"
    "$HOME/.local/bin"
    "/opt/homebrew/opt/python@3.13/libexec/bin"
    "$FNM_PATH"
    "/usr/local/bin"
    "/usr/bin"
    "/bin"
    "/usr/sbin"
    "/sbin"
  )

  for p in "${paths_to_prepend[@]}"; do
    [ -z "$p" ] && continue
    case ":$PATH:" in
      *":$p:"*) ;;           # already present, skip
      *) PATH="$p:$PATH" ;;  # prepend when missing
    esac
  done
  export PATH
}
